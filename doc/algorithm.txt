

# join duplications blocks in a MAF
joinDups(malnSet)
  - foreach block-A in malnSet:
    - foreach block-B in malnSet where its root component overlaps
              the block A root component:
      - merge block-B into block-A
      - delete block-B.

# load a MAF file into an malnSet
loadMaf(mafFile)
  - convert MAF to an malnSet
  - joinDups(malnSet)

# Join two malnSet objects based on a reference genome
malnJoinSets(refGenome, malnSet1, malnSet2, maxBlkWidth)
  - create empty malnSetJoin
  - foreach block-A in malnSet1:
    - foreach refGenome component-A in block-A:
      - foreach component-B in malnSet2 with overlaps or is
        adjacent with component-A:
        - if component-A and component-B can be merged (one is a root):
          merge block-A and block-B into new block-C
        - continue scanning for others to merge into block-C
### FIXME: discuse root vs leaf join
### Split at gaps, cutoff at gaps other that root



# merge components in blocks that could be one component
mergeComps(malnSet)
  - <FILL IN>

- mafJoin(refGenone, maf1File, maf2File, mafOutFile):
  - malnSet1 = loadMaf(maf1)
  - malnSet2 = loadMaf(maf2)
  - malnSetJoin = malnJoinSets(refGenome, malnSet1, malnSet2, maxBlkWidth)
  - joinDups(malnSet)  # this should not be needed, but shouldn't do anything??
  - mergeComps(malnSet)
  - multiParentResolve(malnSet)
